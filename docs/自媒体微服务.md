# 1.自媒体平台登陆
* 与App登陆过程相同，登陆后街面如下：

![](/resources/自媒体.png)

# 2.自媒体素材管理
* ①：前端发送上传图片请求，类型为MultipartFile
* ②：网关进行token解析后，把解析后的用户信息存储到header中
* ③：自媒体微服务使用拦截器获取到header中的的用户信息，并放入到threadlocal中
* ④：先把图片上传到minIO中，获取到图片请求的路径
* ⑤：把用户id和图片上的路径保存到素材表中

## a) 图片上传接口定义
|          | **说明**                        |
| -------- | ------------------------------- |
| 接口路径 | /api/v1/material/upload_picture |
| 请求方式 | POST                            |
| 参数     | MultipartFile                   |
| 响应结果 | ResponseResult                  |

## b) 素材列表查询接口定义
|          | **说明**              |
| -------- | --------------------- |
| 接口路径 | /api/v1/material/list |
| 请求方式 | POST                  |
| 参数     | WmMaterialDto         |
| 响应结果 | ResponseResult        |

## c) 频道列表查询接口定义
|          | **说明**                 |
| -------- | ------------------------ |
| 接口路径 | /api/v1/channel/channels |
| 请求方式 | POST                     |
| 参数     | 无                       |
| 响应结果 | ResponseResult           |

## d) 自媒体文章列表查询接口定义
|          | **说明**          |
| -------- | ----------------- |
| 接口路径 | /api/v1/news/list |
| 请求方式 | POST              |
| 参数     | WmNewsPageReqDto  |
| 响应结果 | ResponseResult    |

# 3. 文章（新增/修改）保存流程
![](/resources/文章保存.png)

1.前端提交发布或保存为草稿

2.后台判断请求中是否包含了文章id

3.如果不包含id,则为新增

​   3.1 执行新增文章的操作

​   3.2 关联文章内容图片与素材的关系

​   3.3 关联文章封面图片与素材的关系

4.如果包含了id，则为修改请求

​   4.1 删除该文章与素材的所有关系

​   4.2 执行修改操作

​   4.3 关联文章内容图片与素材的关系

​   4.4 关联文章封面图片与素材的关系

## a) 文章保存接口定义
|          | **说明**               |
| -------- | ---------------------- |
| 接口路径 | /api/v1/channel/submit |
| 请求方式 | POST                   |
| 参数     | WmNewsDto              |
| 响应结果 | ResponseResult         |

## b) 自媒体文章自动审核流程
![](/resources/文章审核.png)

1.自媒体端发布文章后，开始审核文章

2.审核的主要是审核文章的内容（文本内容和图片）

3.借助第三方提供的接口审核文本

4.借助第三方提供的接口审核图片，由于图片存储到minIO中，需要先下载才能审核

5.如果审核失败，则需要修改自媒体文章的状态，status:2 审核失败 status:3 转到人工审核

6.如果审核成功，则需要在文章微服务中创建app端需要的文章

### 百度智能云内容审核平台 
* 服务链接： https://cloud.baidu.com/doc/ANTIPORN/index.html
* 图片审核接口：
```java
public class GreenImageScan {
    //设置APPID/AK/SK
    private String APP_ID;
    private String API_KEY;
    private String SECRET_KEY;

    public Map<String, String> imageScan(byte[] imgByte) {
        // 初始化一个AipContentCensor
        AipContentCensor client = new AipContentCensor(APP_ID, API_KEY, SECRET_KEY);
        Map<String, String> resultMap = new HashMap<>();
        JSONObject res = client.imageCensorUserDefined(imgByte, null);
        System.out.println(res.toString(2));
        //返回的响应结果
        Map<String, Object> map = res.toMap();
//        获得特殊字段
        String conclusion = (String) map.get("conclusion");

        if (conclusion.equals("合规")) {
            resultMap.put("conclusion", conclusion);
            return resultMap;
        }
//        获得特殊集合字段
        JSONArray dataArrays = res.getJSONArray("data");
        String msg = "";
        for (Object result : dataArrays) {
            //获得原因
            msg = ((JSONObject) result).getString("msg");
        }

        resultMap.put("conclusion", conclusion);
        resultMap.put("msg", msg);
        return resultMap;

    }
}
```

* 文本审核接口：
```java
public class GreenTextScan {
    //设置APPID/AK/SK
    private String APP_ID;
    private String API_KEY;
    private String SECRET_KEY;

    public Map<String, String> textScan(String content) {
        // 初始化一个AipContentCensor
        AipContentCensor client = new AipContentCensor(APP_ID, API_KEY, SECRET_KEY);
        Map<String, String> resultMap = new HashMap<>();
        JSONObject res = client.textCensorUserDefined(content);
        System.out.println(res.toString(2));
        //返回的响应结果
        Map<String, Object> map = res.toMap();
//        获得特殊字段
        String conclusion = (String) map.get("conclusion");

        if (conclusion.equals("合规")) {
            resultMap.put("conclusion", conclusion);
            return resultMap;
        }
//        获得特殊集合字段
        JSONArray dataArrays = res.getJSONArray("data");
        String msg = "";
        for (Object result : dataArrays) {
            //获得原因
            msg = ((JSONObject) result).getString("msg");
        }

        resultMap.put("conclusion", "合格");
        resultMap.put("msg", msg);
        return resultMap;
    }
}
```

## c) 在文章审核成功以后需要在app的article库中新增文章数据
1.保存文章信息 ap_article

2.保存文章配置信息 ap_article_config

3.保存文章内容 ap_article_content

## d) we-media微服务通过feign接口远程调用article微服务

|          | **说明**             |
| -------- | -------------------- |
| 接口路径 | /api/v1/article/save |
| 请求方式 | POST                 |
| 参数     | ArticleDto           |
| 响应结果 | ResponseResult       |

* feign远程接口调用方式
![](/resources/feign远程调用.png)

- feign服务降级
    - 服务降级是服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃

    - 服务降级虽然会导致请求失败，但是不会导致阻塞。

-  实现步骤
    - ①：在heima-leadnews-feign-api编写降级逻辑，在自媒体微服务中添加类，扫描降级代码类的包

    - ②：远程接口中指向降级代码

    - ③：客户端开启降级heima-leadnews-wemedia

## e) 异步线程的方式审核文章
①：在自动审核的方法上加上@Async注解（标明要异步调用）

②：在文章发布成功后调用审核的方法

③：在自媒体引导类中使用@EnableAsync注解开启异步调用

## f) 自己维护一套敏感词，DFA实现
* DFA全称为：Deterministic Finite Automaton,即确定有穷自动机。
* 存储：一次性的把所有的敏感词存储到了多个map中，就是下图表示这种结构:

![](/resources/DFA.png)

## g) 过滤掉图片文字的敏感词
* OCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程

* Tess4j案例:
```java
    /**
     * 识别图片中的文字
     * @param args
     */
    public static void main(String[] args) throws TesseractException {
//        创建实例
        ITesseract tesseract = new Tesseract();
//        设置字体库路径
        tesseract.setDatapath("/opt/local/share/tessdata");
//        设置语言--简体中文
        tesseract.setLanguage("chi_sim");

        File file = new File("/Users/yangjianing/Desktop/test.png");

//        识别图片
        String result = tesseract.doOCR(file);
        System.out.println("识别的结果为：" + result);
    }
```

## h) 上下架接口定义
|          | **说明**                |
| -------- | ----------------------- |
| 接口路径 | /api/v1/news/down_or_up |
| 请求方式 | POST                    |
| 参数     | DTO                     |
| 响应结果 | ResponseResult          |